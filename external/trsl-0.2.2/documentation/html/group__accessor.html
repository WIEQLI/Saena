<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<html>
<head>
  <meta http-equiv="content-type" content="text/html; charset=utf-8">
  <title>Template Range Sampling Library: Accessors</title>
  <link href="doxygen.css" rel="stylesheet" type="text/css">
  <link href="tabs.css" rel="stylesheet" type="text/css">
</head>
<body style="padding: 0px; margin: 8px;">
  <div style="border: 1px solid rgb(0,71,142);">
<!--    <div style="text-align: center; margin-bottom: 8px;">
      <span style="padding-left: 4px; padding-right: 4px; font-size: 160%; color: rgb(0,71,142); border: 1px solid rgb(0,71,142); border-top: 2px solid white;">Template Range Sampling Library</span>
    </div> -->
    <div style="text-align: center"><a href="http://trsl.sourceforge.net/" ><img alt="trsl logo" src="trsl_logo.jpg" align="middle"></a></div>
    <div style="padding: 8px;">
<!-- Generated by Doxygen 1.6.1 -->
<div class="navigation" id="top">
  <div class="tabs">
    <ul>
      <li><a href="index.html"><span>Main&nbsp;Page</span></a></li>
      <li><a href="modules.html"><span>Modules</span></a></li>
      <li><a href="namespaces.html"><span>Namespaces</span></a></li>
      <li><a href="annotated.html"><span>Classes</span></a></li>
      <li><a href="files.html"><span>Files</span></a></li>
      <li><a href="examples.html"><span>Examples</span></a></li>
    </ul>
  </div>
</div>
<div class="contents">
<h1>Accessors</h1><table border="0" cellpadding="0" cellspacing="0">
</table>
<p>Accessors are usually called at least once for each element of the accessed collection. Hence, they should be designed carefully in every situation where performance is an issue. For example, one can gain a lot by having the compiler inline accessors.</p>
<h2><a class="anchor" id="accessor_accessor_types">
Accessor Types</a></h2>
<p>This section describes different types of accessor. In the following, we assume elements to be <code>Particle</code>s. </p>
<div class="fragment"><pre class="fragment"> <span class="keyword">class </span>Particle
 {
 <span class="keyword">public</span>:
   Particle(<span class="keywordtype">double</span> weight, <span class="keywordtype">double</span> x, <span class="keywordtype">double</span> y) :
     x_(x), y_(y), weight_(weight) {}
   
   <span class="keywordtype">void</span> setWeight(<span class="keyword">const</span> <span class="keywordtype">double</span> weight) { weight_ = weight; }
   <span class="keywordtype">double</span> getWeight()<span class="keyword"> const </span>{ <span class="keywordflow">return</span> weight_; };
 
 <span class="keyword">private</span>:
   <span class="keywordtype">double</span> x_;
   <span class="keywordtype">double</span> y_;
   <span class="keywordtype">double</span> weight_;
 };
</pre></div><h3><a class="anchor" id="accessor_functor">
Functor</a></h3>
<div class="fragment"><pre class="fragment"> <span class="keyword">struct </span>functor_weight_accessor {
   <span class="keywordtype">double</span> operator() (<span class="keyword">const</span> Particle&amp; p)<span class="keyword"> const</span>
<span class="keyword">   </span>{ <span class="keywordflow">return</span> p.getWeight(); }
 };
</pre></div><dl>
<dt>Accessor Type </dt>
<dd><code>functor_weight_accessor</code> </dd>
<dt>Accessor object, to pass to the object that needs access </dt>
<dd><code>functor_weight_accessor()</code> </dd>
</dl>
<p>An example of functor accessor is <a class="el" href="structtrsl_1_1weight__accessor.html" title="Weight accessor that always returns 1.">trsl::weight_accessor</a>, which always returns 1 &mdash; useful if elements have uniform weights.</p>
<h3><a class="anchor" id="accessor_functionpointer">
Function Pointer</a></h3>
<div class="fragment"><pre class="fragment"> <span class="keywordtype">double</span> function_pointer_weight_accessor(<span class="keyword">const</span> Particle&amp; p)
 { <span class="keywordflow">return</span> p.getWeight(); }
</pre></div><dl>
<dt>Accessor Type </dt>
<dd><code>std::pointer_to_unary_function&lt;const Particle&amp;, double&gt;</code> </dd>
<dt>Accessor object, to pass to the object that needs access </dt>
<dd><code>std::ptr_fun(function_pointer_weight_accessor)</code> </dd>
</dl>
<h3><a class="anchor" id="accessor_methodpointer">
Method Pointer</a></h3>
<dl>
<dt>Accessor Type </dt>
<dd><code>std::const_mem_fun_ref_t&lt;double, Particle&gt;</code> </dd>
<dt>Accessor object, to pass to the object that needs access </dt>
<dd><code>std::mem_fun_ref(&amp;Particle::getWeight)</code> </dd>
</dl>
<p>Method pointer is currently the default in <a class="el" href="classtrsl_1_1is__picked__systematic.html" title="Functor to use with persistent_filter_iterator for systematic sampling of a range...">trsl::is_picked_systematic</a> (but subject to change, see <a class="el" href="group__accessor.html#accessor_discussion">Discussion</a>). The implementation used in TRSL is not std::const_mem_fun_ref_t however, but <a class="el" href="classtrsl_1_1mp__weight__accessor.html" title="Method Pointer weight accessor.">trsl::mp_weight_accessor</a> which allows a default construction without implying segfault when called &mdash; that comes with a price, see <a class="el" href="classtrsl_1_1mp__weight__accessor.html" title="Method Pointer weight accessor.">trsl::mp_weight_accessor</a>.</p>
<dl>
<dt>Accessor Type </dt>
<dd><code>trsl::mp_weight_accessor&lt;double, Particle&gt;</code> </dd>
<dt>Accessor object, to pass to the object that needs access </dt>
<dd><code>&amp;Particle::getWeight</code> (implicit conversion) </dd>
</dl>
<p>The pointer to <code>getWeight</code> implicitly constructs a <a class="el" href="classtrsl_1_1mp__weight__accessor.html" title="Method Pointer weight accessor.">trsl::mp_weight_accessor</a>. (Why does the std counterpart have an explicit constructor?)</p>
<h2><a class="anchor" id="accessor_discussion">
Discussion</a></h2>
<p>I had the impression that GCC was able to inline fuctions from pointers. Performance tests on accessors (see <code>tests/accessor_efficiency.cpp</code>) tend to contradict this impression. With <code>-03</code> optimization, the functor accessor is twice as fast as other accessors. Please comment if you know more about this. </p>
</div>
</div>
    <div style="border-top: 1px dashed rgb(0,71,142); margin-top: 1ex; font-size: 75%;">
      <div style="text-align: center; color: gray; padding: 8px;">
        Â© Copyright 2007-2008 Renaud Detry.<br>
        Distributed under the Boost Software License, Version 1.0.<br>
        (See accompanying file <a style="color: gray;" href="LICENSE_1_0.txt">LICENSE_1_0.txt</a> or copy at <a style="color: gray;" href="http://www.boost.org/LICENSE_1_0.txt">www.boost.org/LICENSE_1_0.txt</a>.)<br>
        Revised Wed Apr 6 11:43:15 2011.
      </div>
      <div style="text-align: center;">
        <a href="http://sourceforge.net"><img src="http://sflogo.sourceforge.net/sflogo.php?group_id=212585&amp;type=4" width="125" height="37" align="middle" border="0" alt="SourceForge.net Logo"></a>
      </div>
    </div>
  </div>
  <script type="text/javascript">
var gaJsHost = (("https:" == document.location.protocol) ? "https://ssl." : "http://www.");
document.write(unescape("%3Cscript src='" + gaJsHost + "google-analytics.com/ga.js' type='text/javascript'%3E%3C/script%3E"));
</script>
<script type="text/javascript">
try {
var pageTracker = _gat._getTracker("UA-11837709-2");
pageTracker._trackPageview();
} catch(err) {}</script>
<!-- Piwik -->
<script type="text/javascript">
var pkBaseURL = (("https:" == document.location.protocol) ? "https://sourceforge.net/apps/piwik/trsl/" : "http://sourceforge.net/apps/piwik/trsl/");
document.write(unescape("%3Cscript src='" + pkBaseURL + "piwik.js' type='text/javascript'%3E%3C/script%3E"));
</script><script type="text/javascript">
piwik_action_name = '';
piwik_idsite = 1;
piwik_url = pkBaseURL + "piwik.php";
piwik_log(piwik_action_name, piwik_idsite, piwik_url);
</script>
<object><noscript><p><img src="http://sourceforge.net/apps/piwik/trsl/piwik.php?idsite=1" alt="piwik"/></p></noscript></object>
<!-- End Piwik Tag -->
</body>
</html>
